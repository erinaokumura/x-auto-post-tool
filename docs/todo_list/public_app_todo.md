# 公開までのTODOリスト（手動実行版）

## Phase 1: 基盤構築 (1-2週間)

### 1.1 プロジェクト構造の整理
- [×] 既存コードのリファクタリング
  - [×] モジュール分割の最適化
  - [×] 設定ファイルの整理
  - [×] 環境変数の統一管理
- [×] 依存関係の整理
  - [×] requirements.txtの更新
  - [×] 不要な依存関係の削除
  - [×] バージョン固定

#### 疎通確認チェックリスト
- [×] FastAPIサーバーがローカルで起動する
- [×] `/health` などのシンプルなGETエンドポイントが200で返る
  - 構築手順:
    - `main.py`（または`app/main.py`）に最小限のFastAPIアプリを作成
    - `uvicorn app.main:app --reload` で起動
    - ブラウザやcurlで `http://localhost:8000/health` にアクセスし、"ok"などのレスポンスを確認

### 1.2 データベース設計
- [×] PostgreSQLスキーマ設計
  - [×] ユーザーテーブル
  - [×] OAuthトークンテーブル
  - [×] 投稿履歴テーブル
  - [×] 設定テーブル
- [×] マイグレーションスクリプト作成
- [×] 初期データ投入スクリプト

#### 疎通確認チェックリスト
- [×] DBに接続できる
- [×] usersテーブルなど、最低限のテーブルが作成されている
- [×] SELECT/INSERTが正常に動作する
  - 構築手順:
    - `docker-compose`やローカルPostgreSQLを用意
    - `alembic`やSQLスクリプトでテーブル作成
    - FastAPIからDB接続設定（`DATABASE_URL`など）
    - サンプルAPIでDBにデータをINSERT/SELECTし、動作確認

### 1.3 Redis設定
- [×] セッション管理の実装
- [×] （必要に応じて）キャッシュ戦略の設計

#### 疎通確認チェックリスト
- [×] Redisに接続できる
- [×] セッションやキャッシュのset/getができる
  - 構築手順:
    - `docker-compose`やローカルRedisを用意
    - `redis-py`などで接続テスト
    - FastAPIのエンドポイントでset/getを実装し、値が保存・取得できるか確認

## Phase 2: 認証システム強化 (1週間)

### 2.1 OAuth2.0 PKCE完全実装
- [×] トークン永続化の実装
  - [×] データベース保存
  - [×] 自動リフレッシュ
  - [×] 有効期限管理
  - [×] トークンの暗号化保存  # セキュリティ強化のため追加
- [×] セッション管理の改善
- [×] ログアウト機能

#### 疎通確認チェックリスト
- [×] ログイン画面からX（Twitter）認証画面に遷移できる
- [×] 認証後、コールバックでトークンが取得できる
- [×] トークンがDBやRedisに保存される
  - 構築手順:
    - X（Twitter）APIのアプリ登録・クレデンシャル取得
    - 認証用エンドポイント（例：`/login`, `/callback`）を実装
    - 認証フローを一度通して、トークンが保存されるか確認

#### 軽微なバグ修正
- [×] callbackが2回呼ばれて、1回目は失敗している、2回目は成功します。最初に失敗表示がされてからダッシュボードにリダイレクトされる事象を解消
- [×] 実際にはX投稿に成功しているが失敗表示がされる


### 2.2 セキュリティ強化

#### 現在実装済み
- [×] OAuthトークンの暗号化保存（Fernet暗号化）
- [×] トークンの自動リフレッシュ機能
- [×] トークンの有効期限管理
- [×] Redisベースのセッション管理
- [×] HTTPOnly Cookieの使用

#### 🔴 高優先度（すぐに実装すべき）
- [×] CORS設定の実装
  - [×] フロントエンド（localhost:3000）からのAPIアクセス許可
  - [×] 本番環境での適切なオリジン制限設定
  - [×] 環境変数による設定管理
- [×] レート制限の実装
  - [×] API呼び出し制限でDoS攻撃対策（slowapi使用）
  - [×] Twitter API: 10/分、自動投稿: 5/分
  - [×] 認証API: ログイン 10/分、OAuth 20-30/分
  - [×] Redis ベースの制限管理
- [×] HTTPS強制とセキュアCookie設定
  - [×] 本番環境での`secure=True`設定
  - [×] Cookie のセキュリティ強化
  - [×] HTTPS強制リダイレクトミドルウェア
- [×] セキュリティヘッダーの追加
  - [×] CSP（Content Security Policy）- 開発/本番環境別設定
  - [×] HSTS（HTTP Strict Transport Security）
  - [×] X-Frame-Options、X-Content-Type-Options等
  - [×] Permissions Policy、Referrer Policy

#### 🟡 中優先度（近いうちに実装）
- [×] 入力値検証の強化
  - [×] ツイート内容の文字数制限（1-280文字）
  - [×] XSS対策: 危険なHTML/JSパターンの検出
  - [×] 制御文字の除去
  - [×] GitHubリポジトリ名の形式検証
  - [×] OAuth パラメータの安全性チェック
  - [×] Pydantic Field制約の強化
- [ ] JWT実装の検討
  - 現在のセッション管理で十分だが将来的に有用
  - モバイルアプリ対応時に検討

#### 🟢 低優先度（将来的に検討）
- [ ] ログ監視・侵入検知システム
- [ ] APIバージョニング対応
- [ ] OAuth PKCE の完全検証強化

## Phase 3: 手動実行システム (1週間)

### 3.1 同期処理の最適化
- [×] GitHub API取得処理の最適化
  - [×] Redisキャッシュ機能（5分間）
  - [×] 非同期版API（httpx使用）
  - [×] レート制限監視・GitHub認証トークン対応
  - [×] タイムアウト・接続エラーハンドリング強化
  - [×] 適切なHTTPヘッダー設定
- [×] OpenAI API呼び出しの最適化
  - [×] GPT-4o-mini利用でコスト80%削減
  - [×] プロンプト最適化（トークン数削減）
  - [×] 24時間キャッシュ機能
  - [×] 非同期ストリーミング対応
  - [×] バッチ処理機能
  - [×] パラメータ調整（temperature, top_p）
- [×] X投稿処理の最適化
  - [×] リトライ機能（指数バックオフ、最大3回）
  - [×] レート制限対応・自動待機
  - [×] 投稿履歴管理・重複投稿防止
  - [×] 非同期版API（httpx使用）
  - [×] バッチ投稿・並列処理対応
  - [×] エラー分類（一時的/永続的）
- [×] エラーハンドリング
  - [×] 統一例外処理システム
  - [×] サーキットブレーカーパターン実装
  - [×] 構造化ログ・Redis統計保存
  - [×] エラー統計・リアルタイム集計
  - [×] グローバル例外ハンドラー統合

#### 疎通確認チェックリスト
- [×] GitHub APIからリポジトリ情報などが取得できる
- [×] OpenAI APIでテキスト生成ができる
- [×] X APIでテスト投稿ができる（テスト用アカウント推奨）
  - 構築手順:
    - 各APIのクレデンシャルを.envに設定
    - サンプルAPI（例：`/github-test`, `/openai-test`, `/x-test`）を作成
    - 各APIにリクエストし、レスポンスが得られるか確認

### 3.2 システム監視・管理機能（新規追加）
- [×] 詳細ヘルスチェックAPI（`/api/system/health`）
- [×] システムメトリクス取得（`/api/system/metrics`）
- [×] キャッシュ統計・管理（`/api/system/cache/*`）
- [×] パフォーマンス履歴追跡
- [×] API使用統計取得
- [×] エラー統計・監視機能

### 3.3 実行状態管理
- [×] 実行時間測定・ログ出力
- [ ] プログレスバー実装（フロントエンド）
- [×] 実行結果の詳細表示
- [×] エラー時の自動再試行機能（リトライ・サーキットブレーカー）

### 3.4 新しい最適化APIエンドポイント
- [×] `/api/auto_post_tweet_async` - 非同期版自動投稿（推奨）
- [×] 既存APIの最適化（キャッシュ、エラーハンドリング強化）
- [×] 設定可能な最適化パラメータ（環境変数）

## Phase 4: API設計・実装 (1-2週間)

### 4.1 RESTful API設計
- [×] APIエンドポイント設計
  - [×] ユーザー管理API（認証・OAuth）
  - [×] 手動投稿実行API（同期・非同期版）
  - [×] 投稿履歴取得API（Redis管理）
  - [×] システム管理・監視API
- [×] OpenAPI仕様書作成（Swagger UI対応）
- [×] API設計ドキュメント最新化（`docs/api_design.md`）
- [ ] APIバージョニング（将来対応）

#### 疎通確認チェックリスト
- [×] 各APIエンドポイントが正しく動作し、想定通りのレスポンスが返る
  - 構築手順:
    - FastAPIで各APIエンドポイントを実装
    - curlやhttpie、Postman等でAPIを叩き、レスポンスを確認
    - OpenAPIドキュメント（/docs）で仕様を確認

### 4.2 エラーハンドリング
- [×] 統一エラーレスポンス（`app/utils/error_handler.py`）
- [×] ログ出力の標準化（構造化ログ・Redis統計）
- [×] 監視・アラート設定（システムメトリクスAPI）
- [×] サーキットブレーカーによる障害対応
- [×] グローバル例外ハンドラー統合

## Phase 5: フロントエンド開発 (2-3週間)

### 5.1 Next.jsプロジェクト作成
- [×] プロジェクト初期化
- [×] TypeScript設定
- [×] スタイリング（Tailwind CSS）
- [×] コンポーネント設計

#### 疎通確認チェックリスト
- [×] Next.jsアプリが起動し、トップページが表示される
- [×] API（FastAPI）と通信できる（例：ログイン、/health取得）
  - 構築手順:
    - `npx create-next-app` でプロジェクト作成
    - 必要ならTypeScript化・Tailwind導入
    - API呼び出し用のfetch/axios実装
    - ログインボタンやAPI疎通ボタンを設置し、動作確認

### 5.2 認証フロー実装
- [×] ログインページ
- [×] OAuth認証フロー
- [×] ダッシュボード

### 5.3 手動投稿機能
- [×] 投稿実行ボタン
- [×] 投稿結果詳細表示

## Phase 6: インフラ構築 (1週間)

### 6.1 Railway設定
- [×] プロジェクト作成
- [×] PostgreSQL設定
- [×] Redis設定
- [ ] 環境変数設定
- [ ] デプロイ設定

### 6.2 Vercel設定
- [ ] プロジェクト作成
- [ ] ドメイン設定
- [ ] 環境変数設定
- [ ] デプロイ設定

### 6.3 CI/CD設定
- [ ] GitHub Actions設定
- [ ] 自動テスト
- [ ] 自動デプロイ
- [ ] 品質チェック

#### 疎通確認チェックリスト
- [ ] GitHub Actionsでテスト・ビルドが自動実行される
- [ ] Railway/Vercelでアプリがデプロイされ、外部からアクセスできる
  - 構築手順:
    - GitHubリポジトリ作成・push
    - Railway/Vercelでプロジェクト作成・GitHub連携
    - デプロイ後、URLでアプリが動作するか確認

## Phase 7: テスト・品質保証 (1週間)

### 7.1 テスト実装
- [ ] ユニットテスト
- [ ] 統合テスト
- [ ] E2Eテスト
- [ ] パフォーマンステスト

### 7.2 セキュリティテスト
- [ ] 脆弱性スキャン
- [ ] ペネトレーションテスト
- [ ] OAuth認証テスト

### 7.3 負荷テスト
- [ ] API負荷テスト
- [ ] データベース負荷テスト
- [ ] キャッシュ効果測定

## Phase 8: ドキュメント・準備 (1週間)

### 8.1 ドキュメント作成
- [ ] README.md更新
- [ ] API仕様書
- [ ] セットアップガイド
- [ ] ユーザーガイド

### 8.2 法的準備
- [ ] プライバシーポリシー
- [ ] 利用規約
- [ ] 免責事項

### 8.3 マーケティング準備
- [ ] ランディングページ
- [ ] プロダクト説明
- [ ] スクリーンショット・動画

## Phase 9: ベータテスト (1週間)

### 9.1 内部テスト
- [ ] 機能テスト
- [ ] ユーザビリティテスト
- [ ] パフォーマンス確認
- [ ] バグ修正

### 9.2 外部テスト
- [ ] ベータユーザー募集
- [ ] フィードバック収集
- [ ] 改善点の実装

## Phase 10: 公開準備 (1週間)

### 10.1 最終調整
- [ ] バグ修正
- [×] パフォーマンス最適化（Phase 3で先行実装済み）
- [ ] セキュリティ最終確認

### 10.2 公開設定
- [ ] ドメイン設定
- [ ] SSL証明書確認
- [ ] 監視設定
- [ ] バックアップ設定

### 10.3 公開
- [ ] ソーシャルメディア投稿
- [ ] 技術ブログ記事
- [ ] コミュニティ共有

## 優先度別タスク

### 高優先度（MVP必須）
1. [×] OAuth2.0 PKCE完全実装
2. [×] データベース設計・実装
3. [×] 手動投稿実行API（同期・非同期版）
4. [ ] シンプルなフロントエンド
5. [ ] Railway・Vercelデプロイ

### 中優先度（品質向上）
1. [×] 実行状態管理（システム監視API）
2. [ ] テスト実装
3. [×] エラーハンドリング（サーキットブレーカー等）
4. [×] セキュリティ強化
5. [×] ドキュメント整備（API設計書更新）

### 新規追加（最適化・監視）
1. [×] パフォーマンス最適化（キャッシュ・非同期処理）
2. [×] システム監視・メトリクス収集
3. [×] API使用統計・エラー追跡
4. [×] 運用効率向上（自動復旧機能）

### 低優先度（将来拡張）
1. 投稿履歴分析
2. マルチプラットフォーム対応
3. モバイルアプリ
4. チーム機能
5. 有料プラン

## リスク管理

### 技術的リスク
- [×] X API制限への対応（レート制限監視・自動待機・リトライ）
- [×] OpenAI API制限への対応（キャッシュ・GPT-4o-mini・制限監視）
- [ ] データベース容量計画
- [×] 同期処理のタイムアウト対策（非同期処理・サーキットブレーカー）

### 運用リスク
- [×] 監視・アラート設定（システムメトリクス・エラー統計API）
- [ ] バックアップ戦略
- [×] 障害復旧手順（サーキットブレーカー・自動復旧）
- [ ] サポート体制

## 成功指標

### 技術指標
- API応答時間 < 30秒（投稿実行時）※キャッシュヒット時は2-5秒
- 稼働率 > 99.9%（サーキットブレーカーによる自動復旧）
- エラー率 < 1%（統一エラーハンドリング・リトライ機能）
- コスト削減：OpenAI API利用料80%削減（GPT-4o-mini + キャッシュ）
- システム監視：リアルタイムメトリクス・エラー統計収集済み

### ビジネス指標
- 月間アクティブユーザー
- 投稿成功率
- ユーザー満足度

## 予算・リソース

### 月間コスト見積もり
- Vercel: $0-20
- Railway: $0-50
- OpenAI API: $10-100
- その他: $0-30
- **合計: $10-200/月**

### 必要なスキル
- Python/FastAPI
- TypeScript/Next.js
- PostgreSQL
- Redis
- DevOps基礎

## 手動実行の特徴

### メリット
- シンプルな実装
- ユーザーが実行タイミングを制御
- デバッグが容易
- リソース使用量の予測が容易

### ユーザーフロー
1. ユーザーがログイン
2. ダッシュボードで「投稿実行」ボタンをクリック
3. GitHubから最新コミットを取得
4. AIでツイート案を生成
5. Xに投稿
6. 結果を表示

このTODOリストに従って段階的に開発を進めることで、リスクを最小限に抑えながら高品質な手動実行サービスを公開できます。
